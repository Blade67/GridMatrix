module.exports=class{constructor(t,i){this.size=Object.assign({x:0,y:0},t),this.options=Object.assign({allowOverflow:!0,defaultValue:null},i),this.width=NaN!==Number(this.size.width)?Number(this.size.width):0,this.height=NaN!==Number(this.size.height)?Number(this.size.height):0,this.data=generateGridMatrix(this.width,this.height,this.options.defaultValue),this.Directions=Object.freeze({North:0,NorthEast:1,East:2,SouthEast:3,South:4,SouthWest:5,West:6,NorthWest:7})}toArray(){return this.data.flat()}setData(t,i){if(null===i)return;let a=Object.assign({x:0,y:0},t);return void 0!==this.data[a.y][a.x]?(this.data[a.y][a.x]=i,this.data[a.y][a.x]):void 0}getData(t){let i=Object.assign({x:0,y:0},t);if(void 0!==this.data[i.y][i.x])return this.data[i.y][i.x]}getNeighbour(t,i,a){let s=Object.assign({wrap:!1},a),h=Object.assign({x:0,y:0},t);if(void 0===this.data[h.y][h.x])return;if(void 0===Object.values(this.Directions).find(t=>t===i))throw new Error(`Invalid direction "${i}"! Directions:\n${Object.keys(this.Directions).map((t,i)=>t=`${i} - <GridMatrix>.Directions.${t}`).join("\n")}\n`);let e=h.y,r=h.x;try{switch(i){case this.Directions.North:return s.wrap&&h.y-1<0&&(e=this.data.flat().length/this.width),this.data[e-1][r];case this.Directions.NorthEast:return s.wrap&&(h.y-1<0&&(e=this.data.flat().length/this.width),h.x+1>this.data[e-1].length-1&&(r=-1)),this.data[e-1][r+1];case this.Directions.East:return s.wrap&&h.x+1>this.data[e].length-1&&(r=-1),this.data[e][r+1];case this.Directions.SouthEast:return s.wrap&&(h.y+1>this.data.flat().length/this.width-1&&(e=-1),h.x+1>this.data[e+1].length-1&&(r=-1)),this.data[e+1][r+1];case this.Directions.South:return s.wrap&&h.y+1>this.data.flat().length/this.width-1&&(e=-1),this.data[e+1][r];case this.Directions.SouthWest:return s.wrap&&(h.y+1>this.data.flat().length/this.width-1&&(e=-1),h.x-1<0&&(r=this.data[h.y].length)),this.data[e+1][r-1];case this.Directions.West:return s.wrap&&h.x-1<0&&(r=this.data[e].length),this.data[e][r-1];case this.Directions.NorthWest:return s.wrap&&(h.y-1<0&&(e=this.data.flat().length/this.width),h.x-1<0&&(r=this.data[e-1].length)),this.data[e-1][r-1]}}catch(t){return}}getNext(t,i){let a=Object.assign({wrap:!1},i),s=Object.assign({x:0,y:0},t);if(void 0!==this.data[s.y][s.x])return this.width*s.y+s.x+1<this.data.length-1?this.data.flat()[this.width*s.y+s.x+1]:a.wrap?this.data.flat()[0]:void 0}getPrevious(t,i){let a=Object.assign({wrap:!1},i),s=Object.assign({x:0,y:0},t);if(void 0!==this.data[s.y][s.x])return this.width*s.y+s.x-1>0?this.data.flat()[this.width*s.y+s.x-1]:a.wrap?this.data.flat()[this.data.flat().length-1]:void 0}swap(t,i){let a=Object.assign({x:0,y:0},t),s=Object.assign({x:0,y:0},i);if(void 0===this.data[a.y][a.x]&&void 0===this.data[s.y][s.x])return;let h=this.data[a.y][a.x];return this.data[a.y][a.x]=this.data[s.y][s.x],this.data[s.y][s.x]=h,this.data}addColumnBefore(t){if(Array.isArray(t)&&t.length===this.height){for(let i in this.data)this.data[i].unshift(t[i]);return this.width++,this.data}}addColumnAfter(t){if(Array.isArray(t)&&t.length===this.height){for(let i in this.data)this.data[i].push(t[i]);return this.width++,this.data}}removeColumn(t){if(!(t<0||t>this.width)){for(let i in this.data)this.data[i].splice(t,1);return this.data}}addRowBefore(t){if(Array.isArray(t)&&t.length===this.width)return this.data.unshift(t),this.height++,this.data}addRowAfter(t){if(Array.isArray(t)&&t.length===this.width)return this.data.push(t),this.height++,this.data}removeRow(t){if(!(t<0||t>this.width))return this.data.splice(t,1),this.data}};const splitArray=(t,i)=>Array(Math.ceil(t.length/i)).fill().map((t,a)=>a*i).map(a=>t.slice(a,a+i)),generateGridMatrix=(t,i,a)=>{let s=new Array(t*i);for(let t=0;t<s.length;t++)s[t]=a;return splitArray(s,t)};