module.exports=class{constructor(t,i){this.size=Object.assign({x:0,y:0},t),this.options=Object.assign({allowOverflow:!0,defaultValue:null},i),this.width=NaN!==Number(this.size.width)?Number(this.size.width):0,this.height=NaN!==Number(this.size.height)?Number(this.size.height):0,this.data=generateGridMatrix(this.width,this.height,this.options.defaultValue),this.Directions=Object.freeze({North:0,NorthEast:1,East:2,SouthEast:3,South:4,SouthWest:5,West:6,NorthWest:7})}toArray(){return this.data.flat()}setData(t,i){if(null===i)return;let s=Object.assign({x:0,y:0},t);this.data[s.y][s.x]=i}getData(t){let i=Object.assign({x:0,y:0},t);return this.data[i.y][i.x]}getNeighbour(t,i){let s=Object.assign({x:0,y:0},t);if(void 0===Object.values(this.Directions).find(t=>t===i))throw new Error(`Invalid direction "${i}"! Directions:\n${Object.keys(this.Directions).map((t,i)=>t=`${i} - <GridMatrix>.Directions.${t}`).join("\n")}\n`);try{switch(i){case this.Directions.North:return this.data[s.y-1][s.x];case this.Directions.NorthEast:return this.data[s.y-1][s.x+1];case this.Directions.East:return this.data[s.y][s.x+1];case this.Directions.SouthEast:return this.data[s.y+1][s.x+1];case this.Directions.South:return this.data[s.y+1][s.x];case this.Directions.SouthWest:return this.data[s.y+1][s.x-1];case this.Directions.West:return this.data[s.y][s.x-1];case this.Directions.NorthWest:return this.data[s.y-1][s.x-1]}}catch{return}}getNext(t,i){let s=Object.assign({wrap:!1},i),a=Object.assign({x:0,y:0},t);if(void 0!==this.data[a.y][a.x])return this.width*a.y+a.x+1<this.data.length-1?this.data.flat()[this.width*a.y+a.x+1]:s.wrap?this.data.flat()[0]:void 0}getPrevious(t,i){let s=Object.assign({wrap:!1},i),a=Object.assign({x:0,y:0},t);if(void 0!==this.data[a.y][a.x])return this.width*a.y+a.x-1>0?this.data.flat()[this.width*a.y+a.x-1]:s.wrap?this.data.flat()[this.data.flat().length-1]:void 0}swap(t,i){let s=Object.assign({x:0,y:0},t),a=Object.assign({x:0,y:0},i);if(void 0!==this.data[s.y][s.x]&&void 0!==this.data[a.y][a.x]){let t=this.data[s.y][s.x];return this.data[s.y][s.x]=this.data[a.y][a.x],this.data[a.y][a.x]=t,this.data}}};const splitArray=(t,i)=>Array(Math.ceil(t.length/i)).fill().map((t,s)=>s*i).map(s=>t.slice(s,s+i)),generateGridMatrix=(t,i,s)=>{let a=new Array(t*i);for(let t=0;t<a.length;t++)a[t]=s;return splitArray(a,t)};